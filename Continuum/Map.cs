using System;
using System.IO;
using System.Windows.Media.Media3D;

namespace ContinuumNS
{
    /// <summary> Class that holds a map generated by user. Map types include wind speed (waked and unwaked), upwind exposure, downwind exposure, and AEP maps. 
    /// The user specifies map grid extent and resolution and the met sites to use in map generation. </summary>
    [Serializable()]
    public class Map
    {
        /// <summary> Name of map </summary>
        public string mapName;
        /// <summary> Mapped parameter (overall) </summary>
        public double[,] parameterToMap;
        /// <summary> Mapped parameter (sectorwise)  i = X ind; j = Y ind; k = WD sec (for WS maps that have sectorwise WS (so Num k = Num WD sectors) and other maps Num k = 1) </summary>
        public double[,,] sectorParamToMap;
        /// <summary> True if map is complete </summary>
        public bool isComplete = false; // true if map is complete
        /// <summary> 0 = UW map, 1 = DW map, 2 = WS map, 3 = Gross AEP map </summary>
        public int modelType;
        /// <summary> 8000 m: Used when map is an exposure map </summary>
        public int expoMapRadius = 2;
        /// <summary> Power curve used if AEP map </summary>
        public string powerCurve = "";
        /// <summary> Minimum UTMX coordinate of map </summary>
        public int minUTMX;
        /// <summary> Minimum UTMY coordinate of map </summary>
        public int minUTMY;
        /// <summary> Grid size along X </summary>
        public int numX;
        /// <summary> Grid size along Y </summary>
        public int numY;
        /// <summary> Map grid resolution </summary>
        public int reso;

        /// <summary> Met sites used to form the estimates at map nodes. (The model can be formed with a group of mets and then any set of mets can be used to create a map (selected on Gen_Map form) </summary>
        public string[] metsUsed;
        /// <summary> Wind flow models used to create map </summary>
        public Model[] model;
        /// <summary> True if it is a wake map </summary>
        public bool isWaked;
        /// <summary> Wake model used if it is a wake map </summary>
        public Wake_Model wakeModel;
        /// <summary> True if surface roughness model is used </summary>
        public bool useSR;
        /// <summary> True if flow separation model is used </summary>
        public bool useFlowSep;
        /// <summary> True if each map node is estimated using GenerateTimeSeries </summary>
        public bool useTimeSeries;                                

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        /// <summary> Holds all calculated parameters, wind speed and energy estimates at Map node. </summary>
        [Serializable()] public struct MapNode {
            /// <summary> UTM X coordinate. </summary>
            public double UTMX;
            /// <summary> UTM Y coordinate. </summary>
            public double UTMY;
            /// <summary> Elevation. </summary>
            public double elev;
            /// <summary> List of exposures. </summary>
            public Exposure[] expo;
            /// <summary> List of grid statistics (P10 exposure). </summary>
            public Grid_Info gridStats;
            /// <summary> All wind speed estimates formed by each predictor met and each model. </summary>
            public WS_Ests[] WS_Estimates;
            /// <summary> Overall wind speed estimate at map node. </summary>
            public double avgWS_Est;
            /// <summary> Sectorwise wind speed estimates i = Sect num. </summary>
            public double[] sectorWS;
            /// <summary> Overall wind speed distribution. </summary>
            public double[] WS_Dist;
            /// <summary>  Sectorwise wind speed distribution // i = Sector num, j = WS interval. </summary>
            public double[,] sectDist;
            /// <summary> Overall gross AEP, (only if map is Gross AEP). </summary>
            public double grossAEP;
            /// <summary> Sectorwise gross AEP, (only if map is Gross AEP). </summary>
            public double[] sectorGross;
            /// <summary> For wake loss maps where wind speed, wake losses and net energy are calculated. </summary>
            public Net_Energy_Est netEnergyEsts;
            /// <summary> Wind rose estimated at map node by interpolating (based on distance) from met site wind roses. </summary>
            public double[] windRose;
            /// <summary> Used in flow separation model if any sectors have UW Expo less than 0 and DW Expo > 0 then finds the highest point upwind (within 5000 m) and the node at the end of the turbulent zone. These are stored in flowSepNodes array. </summary>
            public NodeCollection.Sep_Nodes[] flowSepNodes;
        }

        /// <summary> Holds wind speed estimate at map node based on predictor met and wind flow model with radius. </summary>
        [Serializable()] public struct WS_Ests
        {
            /// <summary> Predictor Met name. </summary>
            public string predictorMetName;
            /// <summary> Path of nodes between map node and predictor met. </summary>
            public Nodes[] pathOfNodes;
            /// <summary> Radius used in model. </summary>
            public int radius;
            /// <summary> Estimated wind speed. </summary>
            public double WS;
            /// <summary> Wind speed weight (calculated based on similarity in terrain and met cross-predictions error of wind flow model). </summary>
            public double WS_weight;
            /// <summary> Sectorwise wind speed estimates. </summary>
            public double[] sectorWS;   
        }

        /// <summary> Holds net energy (i.e. waked) estimate at map node. </summary>
        [Serializable()] public struct Net_Energy_Est
        {
            /// <summary> Net annual energy estimate. </summary>
            public double est;
            /// <summary> Sectorwise net energy. </summary>
            public double[] sectorEnergy;
            /// <summary> Overall wake loss. </summary>
            public double wakeLoss;
            /// <summary> Sectorwise wake loss. </summary>
            public double[] sectorWakeLoss; // Sectorwise wake loss %
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        /// <summary> Generates wind speed estimates at referenced map node using each met and each Continuum model (i.e. each radius of investigation). </summary>
        public WS_Ests[] DoMapCalcs(Continuum thisInst, MapNode thisMapNode, NodeCollection nodeList)
        {            
            MetCollection metList = thisInst.metList;                                   
            int numMetsUsed = metsUsed.Length;            
            int numRadii = thisInst.radiiList.ThisCount;
                                    
            Met[] theseMets = metList.GetMets(metList.GetMetsUsed(), null);

            int numWS_Ests = numMetsUsed * numRadii;
            WS_Ests[] wsEsts = new WS_Ests[numWS_Ests];
            int WS_Est_ind = 0;

            // For each met and each radius of investigation (i.e. each Continuum model), generate wind speed estimate at map node. 
            for (int j = 0; j < numMetsUsed; j++)
            {               
                for (int r = 0; r < numRadii; r++)
                {                    
                    Nodes mapNode = nodeList.GetMapAsNode(thisMapNode);
                    Nodes metNode = nodeList.GetMetNode(theseMets[j]);

                    wsEsts[WS_Est_ind] = DoWS_EstAlongNodes(thisInst, theseMets[j], r, mapNode, metNode, thisMapNode.windRose, nodeList);
                    WS_Est_ind++;
                }
            }

            return wsEsts;
        }

        /// <summary> Using calculated wake profile polynomials (i.e. wakeLossCoeffs), calculates the wake losses and net energy at the referenced map node. </summary>
        public void CalcWakeLossesMap(ref MapNode thisMapNode, Continuum thisInst, Wake_Model thisWakeModel, WakeCollection.WakeLossCoeffs[] wakeLossCoeffs)
        {            
            WakeCollection.WakeCalcResults wakeResults = thisInst.wakeModelList.CalcWakeLosses(wakeLossCoeffs, thisMapNode.UTMX, thisMapNode.UTMY, 
                thisMapNode.sectDist, thisMapNode.grossAEP, thisMapNode.sectorGross, thisInst, thisWakeModel, thisMapNode.windRose);
                       
            thisMapNode.avgWS_Est = wakeResults.wakedWS;
            thisMapNode.sectDist = wakeResults.sectorDist;
            thisMapNode.sectorWS = wakeResults.sectorWakedWS;

            thisMapNode.netEnergyEsts.est = wakeResults.netEnergy;
            thisMapNode.netEnergyEsts.sectorEnergy = wakeResults.sectorNetEnergy;
            thisMapNode.netEnergyEsts.wakeLoss = wakeResults.wakeLoss;
            thisMapNode.netEnergyEsts.sectorWakeLoss = wakeResults.sectorWakeLoss;

        }

        /// <summary> Combines all wind speed estimates formed by each predictor met and each wind flow model to form average wind speed estimate at map node. </summary>
        public void GenerateAvgWS_AtOneMapNode(ref MapNode thisMapNode, Continuum thisInst, int nodeInd)
        {            
            double avgWS = 0;
            double avgWeight = 0;
                        
            MetCollection metList = thisInst.metList;
            ModelCollection modelList = thisInst.modelList;
            InvestCollection radiiList = thisInst.radiiList;
            
            int numRadii = thisInst.radiiList.ThisCount;
            int numWD = thisInst.metList.numWD;
            thisMapNode.sectorWS = new double[numWD];         
                                             
            double[] sectorWS = new double[numWD];
            int numMetsUsed = metsUsed.Length;
            Met[] predMets = new Met[numMetsUsed];

            for (int i = 0; i < numMetsUsed; i++) { 
                for (int j = 0; j < metList.ThisCount; j++) { 
                    if (metsUsed[i] == metList.metItem[j].name) {
                        predMets[i] = metList.metItem[j];
                        break;
                    }
                }
            }
            
            Model[] models = modelList.GetModels(thisInst, metList.GetMetsUsed(), Met.TOD.All, Met.Season.All, thisInst.modeledHeight, false);
                       
            NodeCollection nodeList = new NodeCollection();
            Nodes MapNode = nodeList.GetMapAsNode(thisMapNode);
            ModelCollection.ModelWeights[] indivMetWeights = modelList.GetWS_EstWeights(predMets, MapNode, models, metList.GetAvgWindRose(thisInst.modeledHeight, Met.TOD.All, Met.Season.All), thisInst.radiiList);

            for (int r = 0; r < numRadii; r++)
            { 
                for (int j = 0; j < thisMapNode.WS_Estimates.Length; j++) {
                    bool isMetUsed = false;

                    for (int k = 0; k < metsUsed.Length; k++) { 
                        if (metsUsed[k] == thisMapNode.WS_Estimates[j].predictorMetName) {
                            isMetUsed = true;                            
                            break;
                        }
                    }

                    if (isMetUsed == true && thisMapNode.WS_Estimates[j].radius == radiiList.investItem[r].radius && thisMapNode.WS_Estimates[j].WS!= 0 ) {

                        Met thisMet = thisInst.metList.GetMet(thisMapNode.WS_Estimates[j].predictorMetName);
                        double weight = thisInst.modelList.GetWeightForMetAndModel(indivMetWeights, thisMet, models[r]);
                        avgWS = Math.Round(avgWS, 5) + Math.Round(thisMapNode.WS_Estimates[j].WS, 5) * Math.Round(weight, 3);
                        thisMapNode.WS_Estimates[j].WS_weight = weight;
                        avgWeight = Math.Round(avgWeight, 3) + Math.Round(weight, 3);

                        for (int WD = 0; WD < numWD; WD++)
                            sectorWS[WD] = sectorWS[WD] + Math.Round(thisMapNode.WS_Estimates[j].sectorWS[WD], 5) * Math.Round(weight, 3);
                    }
                }
            }

            thisMapNode.avgWS_Est = 0; 
            thisMapNode.sectorWS = new double[numWD];

            if (avgWeight != 0) { 
                thisMapNode.avgWS_Est = Math.Round(avgWS, 5) / Math.Round(avgWeight, 3);

                for (int WD = 0; WD < numWD; WD++)
                    thisMapNode.sectorWS[WD] = Math.Round(sectorWS[WD], 5) / Math.Round(avgWeight, 3);  
            }
        }

        /// <summary> Calculates overall and sectorwise wind speed distribution for referenced map node. </summary>
        public void CalcWS_DistAtMapNode(ref MapNode thisMapNode, MetCollection metList, int numWD, double height)
        {            
            string[] metsUsed = metList.GetMetsUsed();

            int numWS = metList.numWS;
            thisMapNode.sectDist = new double[numWD, numWS];

            for (int WD = 0; WD < numWD; WD++) {
                double[] WS_Dist = metList.CalcWS_DistForTurbOrMap(metsUsed, thisMapNode.sectorWS[WD], WD, Met.TOD.All, Met.Season.All, height);
                for (int WS = 0; WS < numWS; WS++)
                    thisMapNode.sectDist[WD, WS] = WS_Dist[WS];
                
            }

            thisMapNode.WS_Dist = metList.CalcOverallWS_Dist(thisMapNode.sectDist, thisMapNode.windRose);
        }

        /// <summary> Calculates gross energy production at referenced mapNode. </summary>        
        public void CalcGrossAEP_AtMapNode(ref MapNode thisMapNode, MetCollection metList, TurbineCollection turbineList)
        {                        
            int numWS = metList.numWS;
            int numWD = metList.numWD;            
            thisMapNode.sectorGross = new double[numWD];                       
            
            TurbineCollection.PowerCurve thisPowerCurve = turbineList.GetPowerCurve(powerCurve);                      

            thisMapNode.grossAEP = 0;

            for (int k = 0; k < numWS; k++) {
                double thisWS = metList.GetWS_atWS_Ind(k);
                double thisPower = turbineList.GetInterpPowerOrThrust(thisWS, thisPowerCurve, "Power");
                thisMapNode.grossAEP = thisMapNode.grossAEP + thisMapNode.WS_Dist[k] * thisPower;
                for (int WD_Ind = 0; WD_Ind < numWD; WD_Ind++)
                    thisMapNode.sectorGross[WD_Ind] = thisMapNode.sectorGross[WD_Ind] + thisMapNode.sectDist[WD_Ind, k] * thisPower;                
            }

            thisMapNode.grossAEP = thisMapNode.grossAEP * 365 * 24 / 1000;
            for (int WD_Ind = 0; WD_Ind < numWD; WD_Ind++)
                thisMapNode.sectorGross[WD_Ind] = thisMapNode.sectorGross[WD_Ind] * 365 * 24 / 1000 * thisMapNode.windRose[WD_Ind];            

        }

        /// <summary> Calculates wind speed from predictor met to Map node along path of nodes.  </summary>  
        public WS_Ests DoWS_EstAlongNodes(Continuum thisInst, Met predictorMet, int radiusInd, Nodes mapNode, Nodes metNode, double[] windRose, NodeCollection nodeList)
        {       
            WS_Ests thisWS = new WS_Ests();
            
            InvestCollection radiiList = thisInst.radiiList;
            ModelCollection modelList = thisInst.modelList;
            Model[] models = modelList.GetModels(thisInst, thisInst.metList.GetMetsUsed(), Met.TOD.All, Met.Season.All, thisInst.modeledHeight, false);
            Model thisModel = models[radiusInd];

            thisWS.predictorMetName = predictorMet.name;
            thisWS.radius = radiiList.investItem[radiusInd].radius;
            thisWS.pathOfNodes = nodeList.FindPathOfNodes(metNode, mapNode, thisModel, thisInst);              

            int numWD = thisInst.metList.numWD;                                                          
                        
            ModelCollection.WS_Est_Struct WS_EstStr = modelList.DoWS_Estimate(predictorMet, mapNode, thisWS.pathOfNodes, thisModel, thisInst);

            thisWS.sectorWS = WS_EstStr.sectorWS;

            // Have sectorwise wind speed at map node now need to calculate avg WS using wind rose            
            for (int WD = 0; WD < numWD; WD++)
                thisWS.WS = thisWS.WS + Math.Round(thisWS.sectorWS[WD] * windRose[WD], 5);

            return thisWS;
        }

        /// <summary> Adds a wind speed estimate to the list of WS_Ests. </summary>        
        public void AddWS_Estimate(ref MapNode thisMapNode, ref WS_Ests newWS_Est)
        {             
            int newCount = 0;
            if (thisMapNode.WS_Estimates != null)
                newCount = thisMapNode.WS_Estimates.Length;
            else
                newCount = 0;

            if (newCount > 0) {
                Array.Resize(ref thisMapNode.WS_Estimates, newCount + 1);
                thisMapNode.WS_Estimates[newCount] = newWS_Est;
            }
            else {
                thisMapNode.WS_Estimates = new WS_Ests[1];
                thisMapNode.WS_Estimates[0] = newWS_Est;
            }

        }

        /// <summary> Checks to see if surface roughness and displacement height have been calculated and returns true if new and needs to be calculated. </summary>     
        public bool IsNewSRDH(MapNode thisMapNode, int radius, double exponent, int numSectors)
        {            
            int thisCount = 0;

            if (thisMapNode.expo != null)
                thisCount = thisMapNode.expo.Length;                       

            bool isNew = false;
            if (thisCount == 0) isNew = true;

            for (int i = 0; i < thisCount; i++) {
                if (thisMapNode.expo[i].exponent == exponent && thisMapNode.expo[i].radius == radius && thisMapNode.expo[i].numSectors == numSectors
                    && thisMapNode.expo[i].SR != null && thisMapNode.expo[i].dispH != null)
                {                     
                    isNew = false;
                    break;
                }
                else
                    isNew = true;                
            }

            return isNew;
        }

        /// <summary> Calculates exposure and SRDH at referenced map node </summary>        
        public void CalcMapExposures(ref MapNode thisMapNode, int numSectors, Continuum thisInst)
        {            
            int numWD = thisInst.GetNumWD();
           
            for (int i = 0; i < thisInst.radiiList.ThisCount; i++) {
                int radius = thisInst.radiiList.investItem[i].radius;
                double exponent = thisInst.radiiList.investItem[i].exponent;

                // First find elevation
                if (thisMapNode.elev == 0)
                    thisMapNode.elev = thisInst.topo.CalcElevs(thisMapNode.UTMX, thisMapNode.UTMY);

                // Check to see if the exposures have already been calculated
                bool isNew = IsNewExposure(thisMapNode, radius, exponent, numSectors);
                bool isNewSRDH = IsNewSRDH(thisMapNode, radius, exponent, numSectors);
                                
                Exposure smallerExposure;

                if (isNew == true) {
                    AddExposure(ref thisMapNode, radius, exponent, numSectors, numWD);
                    
                    // Check to see if an exposure with a smaller radii has been calculated
                    int smallerRadius = thisInst.topo.GetSmallerRadius(thisMapNode.expo, radius, exponent, numSectors);

                    if (smallerRadius == 0 || numSectors > 1) { // when sector avg is used, can't add on to exposure calcs... so gotta do it the long way
                        thisMapNode.expo[i] = thisInst.topo.CalcExposures(thisMapNode.UTMX, thisMapNode.UTMY, thisMapNode.elev, radius, exponent, numSectors, thisInst.topo, numWD);
                        if (thisInst.topo.gotSR == true) {
                            thisInst.topo.CalcSRDH(ref thisMapNode.expo[i], thisMapNode.UTMX, thisMapNode.UTMY, radius, exponent, numWD);
                        }
                    }
                    else {
                        smallerExposure = thisInst.topo.GetSmallerRadiusExpo(thisMapNode.expo, smallerRadius, exponent, numSectors);

                        thisMapNode.expo[i] = thisInst.topo.CalcExposuresWithSmallerRadius(thisMapNode.UTMX, thisMapNode.UTMY, thisMapNode.elev, radius, exponent, numSectors,
                            smallerRadius, smallerExposure, numWD);
                        if (thisInst.topo.gotSR == true)
                            thisInst.topo.CalcSRDHwithSmallerRadius(ref thisMapNode.expo[i], thisMapNode.UTMX, thisMapNode.UTMY, radius, exponent, numSectors, smallerRadius, smallerExposure, numWD);
                    }

                }
                else if (isNewSRDH == true && thisInst.topo.gotSR == true) 
                {                   
                    // Check to see if an exposure with a smaller radii has been calculated
                    int smallerRadius = thisInst.topo.GetSmallerRadius(thisMapNode.expo, radius, exponent, numSectors);

                    if (smallerRadius == 0)
                        thisInst.topo.CalcSRDH(ref thisMapNode.expo[i], thisMapNode.UTMX, thisMapNode.UTMY, radius, exponent, numWD);
                    else {
                        smallerExposure = thisInst.topo.GetSmallerRadiusExpo(thisMapNode.expo, smallerRadius, exponent, numSectors);
                        thisInst.topo.CalcSRDHwithSmallerRadius(ref thisMapNode.expo[i], thisMapNode.UTMX, thisMapNode.UTMY, radius, exponent, numSectors, smallerRadius, smallerExposure, numWD);
                         
                    }
                }
            }

            // Calc P10 UW Crosswind Grade            
            for (int expoInd = 0; expoInd < thisInst.radiiList.ThisCount; expoInd++) {
                thisMapNode.expo[expoInd].UW_P10CrossGrade = new double[numWD];
                thisMapNode.expo[expoInd].UW_ParallelGrade = new double[numWD];
            }

            for (int r = 0; r < numWD; r++) {
                double UW_CW_Grade = thisInst.topo.CalcP10_UW_CrosswindGrade(thisMapNode.UTMX, thisMapNode.UTMY, r, numWD);
                double UW_PL_Grade = thisInst.topo.CalcP10_UW_ParallelGrade(thisMapNode.UTMX, thisMapNode.UTMY, r, numWD);
                for (int expoInd = 0; expoInd < thisInst.radiiList.ThisCount; expoInd++) {
                    thisMapNode.expo[expoInd].UW_P10CrossGrade[r] = UW_CW_Grade;
                    thisMapNode.expo[expoInd].UW_P10CrossGrade[r] = UW_PL_Grade;
                }
            }
        }

        /// <summary> Adds another exposure to the list (sorted by radius). </summary> 
        public void AddExposure(ref MapNode thisMapNode, int radius, double exponent, int numSectors, int numWD)
        {            
            int expoCount = 0;
            int insertInd = 0;

            if (thisMapNode.expo != null)
                expoCount = thisMapNode.expo.Length;
            else
                expoCount = 0;
            
            if (expoCount > 0) {
                if (radius > thisMapNode.expo[expoCount - 1].radius)  // Larger radius than largest in list
                    insertInd = expoCount;
                else if (radius < thisMapNode.expo[0].radius)  // Smaller than smallest in list
                    insertInd = 0;
                else {
                    for (int i = 0; i <= expoCount - 2; i++) { 
                            if (thisMapNode.expo[i].radius < radius && thisMapNode.expo[i + 1].radius >= radius) {
                            insertInd = i + 1;
                            break;
                        }
                    }
                }

                Exposure[] existingExpos = new Exposure[expoCount];

                for (int j = 0; j < expoCount; j++)
                    existingExpos[j] = thisMapNode.expo[j];

                thisMapNode.expo = new Exposure[expoCount + 1];

                for (int j = 0; j < insertInd; j++) 
                    thisMapNode.expo[j] = existingExpos[j]; 

                thisMapNode.expo[insertInd] = new Exposure();
                thisMapNode.expo[insertInd].radius = radius;
                thisMapNode.expo[insertInd].exponent = exponent;
                thisMapNode.expo[insertInd].numSectors = numSectors;
                thisMapNode.expo[insertInd].expo = new double[numWD];

                for (int j = insertInd + 1; j <= expoCount; j++)
                    thisMapNode.expo[j] = existingExpos[j - 1];
            }
            else {
                thisMapNode.expo = new Exposure[1];
                thisMapNode.expo[0] = new Exposure();
                thisMapNode.expo[0].radius = radius;
                thisMapNode.expo[0].exponent = exponent;
                thisMapNode.expo[0].numSectors = numSectors;
                thisMapNode.expo[0].expo = new double[numWD];
            }

        }

        /// <summary> Checks to see if exposure has already been calculated. Returns true if needs to be calculated. </summary> 
        public bool IsNewExposure(MapNode thisMapNode, int radius, double exponent, int numSectors)
        {            
            bool isNew = true;
            if (thisMapNode.expo != null) {
                int thisCount = thisMapNode.expo.Length;
                if (thisCount == 0) isNew = true;

                for (int i = 0; i < thisCount; i++) {
                    if (thisMapNode.expo[i].exponent == exponent && thisMapNode.expo[i].radius == radius && thisMapNode.expo[i].numSectors == numSectors
                        && thisMapNode.expo[i].expo != null)
                    { // the exposures based on radius and exp combo already calculated
                        isNew = false;
                        break;
                    }
                    else
                        isNew = true;                    
                }
            }

            return isNew;
        }

        /// <summary> Finds and returns the minimum value in map. </summary>
        public double FindMin(int WD_Ind, int numWD)
        {             
            double min = 100000;
            double param = 0;

            for (int i = 0; i < numX; i++) { 
                for (int j = 0; j < numY; j++) {
                    if (WD_Ind == numWD || sectorParamToMap == null)
                        param = parameterToMap[i, j];
                    else
                        param = sectorParamToMap[i, j, WD_Ind];

                    if (param < min && param != 0) min = param;
                }
            }

            return min;
        }

        /// <summary> Finds and returns the maximum value in map. </summary>
        public double FindMax(int WD_Ind, int numWD)
        {            
            double max = 0;
            double param = 0;  

            for (int i = 0; i < numX; i++) { 
                for (int j = 0; j < numY; j++) {
                    if (WD_Ind == numWD || sectorParamToMap == null)
                        param = parameterToMap[i, j];
                    else
                        param = sectorParamToMap[i, j, WD_Ind];

                    if (param > max) max = param;
                }
            }

            return max;
        }

        /// <summary> Gets the flow separation nodes for map node (if flow separation model is used). </summary>
        public void GetFlowSepNodes(ref MapNode thisMapNode, Continuum thisInst)
        {            
            int numWD = 0;
            try {
                numWD = thisMapNode.windRose.Length;
            }
            catch {
                return;
            }

            NodeCollection nodeList = new NodeCollection();
            Nodes thisNode = nodeList.GetMapAsNode(thisMapNode);

            thisMapNode.flowSepNodes = nodeList.FindAllFlowSeps(thisNode, thisInst, numWD);

        }

    }
}
